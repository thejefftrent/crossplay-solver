<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crossplay Solver - NYT Style</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for results */
        .results-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .results-scroll::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .results-scroll::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        .results-scroll::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Board Grid Specifics */
        .board-grid {
            display: grid;
            grid-template-columns: repeat(15, minmax(0, 1fr));
            gap: 2px;
            background-color: #cbd5e1; /* Grid line color */
            border: 2px solid #cbd5e1;
            aspect-ratio: 1;
        }

        .cell {
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            position: relative;
            cursor: pointer;
            user-select: none;
            text-transform: uppercase;
        }
        
        /* Style for cells with tiles placed */
        .cell.occupied {
            background-color: #f8fafc; /* Slate-50 */
            box-shadow: inset 0 0 4px rgba(0,0,0,0.1);
        }

        /* Waiting for blank tile input */
        .cell.blank-pending input {
            background-color: #fef08a; /* Yellow-200 */
            border-radius: 2px;
        }

        /* Lowercase letters (Blanks) specific style */
        .cell input.is-blank {
            color: #64748b; /* Slate-500 */
        }
        
        @media (min-width: 640px) {
            .cell { font-size: 1rem; }
        }

        .cell input {
            width: 100%;
            height: 100%;
            text-align: center;
            background: transparent;
            border: none;
            outline: none;
            font-weight: 800;
            color: #1e293b;
            padding: 0;
            margin: 0;
            /* No uppercase transform here to allow showing lowercase blanks */
            z-index: 10; /* Ensure input is above backgrounds */
            border-radius: 0;
        }

        /* Multiplier Colors */
        .mult-2l { background-color: #bfdbfe; } /* Blue-200 */
        .mult-3l { background-color: #86efac; } /* Green-300 */
        .mult-2w { background-color: #fca5a5; } /* Red-300 */
        .mult-3w { background-color: #fdba74; } /* Orange-300 */
        
        /* Phantom/Preview Style */
        .cell.phantom {
            color: #4f46e5; /* Indigo-600 */
            background-color: #e0e7ff; /* Indigo-100 */
        }

        /* Direction Indicator Style */
        .cell.next-target {
            background-image: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 25%, transparent 25%, transparent 50%, rgba(99, 102, 241, 0.1) 50%, rgba(99, 102, 241, 0.1) 75%, transparent 75%, transparent);
            background-size: 4px 4px;
            box-shadow: inset 0 0 0 2px rgba(99, 102, 241, 0.3);
        }
        
        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.9);
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 font-sans min-h-screen">

    <!-- Loading Screen -->
    <div id="loading-overlay">
        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mb-4"></div>
        <h2 class="text-xl font-bold text-slate-700">Loading Dictionary...</h2>
        <p class="text-slate-500 text-sm" id="loading-status">Fetching word list...</p>
    </div>

    <!-- Main Container -->
    <div class="max-w-7xl mx-auto p-4 lg:p-6 grid grid-cols-1 lg:grid-cols-12 gap-6 h-full">
        
        <!-- Left Col: Header & Board -->
        <div class="lg:col-span-7 xl:col-span-8 flex flex-col gap-4">
            <header class="flex justify-between items-center mb-2">
                <div>
                    <h1 class="text-2xl font-bold text-slate-900 tracking-tight">Crossplay<span class="text-indigo-600">Solver</span></h1>
                    <p class="text-sm text-slate-500">Enter board state & rack to find the best move.</p>
                </div>
                <div class="flex gap-2">
                    <button id="reset-board-btn" class="px-3 py-1 text-sm bg-white border border-slate-300 rounded hover:bg-slate-100 transition shadow-sm">Reset</button>
                </div>
            </header>

            <!-- Board Wrapper -->
            <div class="w-full max-w-[600px] mx-auto bg-white p-2 rounded-lg shadow-lg border border-slate-200">
                <div id="game-board" class="board-grid">
                    <!-- Grid generated by JS -->
                </div>
            </div>
            
            <div class="text-xs text-slate-400 text-center mt-1 space-y-1">
                <p><span class="font-bold text-indigo-600">Double-click</span> cell to toggle typing direction (Horizontal/Vertical).</p>
                <p>Type <span class="font-bold font-mono">?</span> then a letter to place a blank (0 points).</p>
            </div>
        </div>

        <!-- Right Col: Controls & Results -->
        <div class="lg:col-span-5 xl:col-span-4 flex flex-col gap-4 h-full">
            
            <!-- Control Panel -->
            <div class="bg-white p-5 rounded-xl shadow-md border border-slate-200">
                <label class="block text-sm font-semibold text-slate-700 mb-2">Your Rack (Use '?' for blank)</label>
                <div class="flex gap-2 mb-4">
                    <input type="text" id="rack-input" maxlength="7" placeholder="ABCDEFG" 
                           class="flex-1 text-2xl tracking-widest uppercase font-bold text-center border-2 border-slate-300 rounded-lg py-2 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 outline-none transition placeholder-slate-300">
                    <button id="clear-rack-btn" class="px-3 text-slate-400 hover:text-red-500 transition">✕</button>
                </div>
                
                <button id="solve-btn" class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg shadow-md transition transform active:scale-95 flex justify-center items-center gap-2">
                    <span>Find Best Move</span>
                    <span id="solve-spinner" class="hidden w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></span>
                </button>
            </div>

            <!-- Results Panel -->
            <div class="bg-white rounded-xl shadow-md border border-slate-200 flex-1 flex flex-col overflow-hidden min-h-[400px]">
                <div class="p-3 border-b border-slate-100 bg-slate-50 flex justify-between items-center">
                    <div class="flex bg-slate-200 p-1 rounded-lg">
                        <button id="sort-score-btn" class="px-3 py-1 text-xs font-bold rounded-md bg-white text-slate-700 shadow-sm transition">Top Scoring</button>
                        <button id="sort-tiles-btn" class="px-3 py-1 text-xs font-bold rounded-md text-slate-500 hover:text-slate-700 transition">Most Tiles</button>
                    </div>
                    <span id="results-count" class="text-xs font-mono text-slate-500">0 found</span>
                </div>
                
                <div id="results-list" class="flex-1 overflow-y-auto results-scroll p-0">
                    <!-- Results injected here -->
                    <div class="p-8 text-center text-slate-400 flex flex-col items-center justify-center h-full">
                        <svg class="w-12 h-12 mb-2 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg>
                        <p>Enter tiles and click Solve</p>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const BOARD_SIZE = 15;
        const DICT_URL = 'https://raw.githubusercontent.com/redbo/scrabble/master/dictionary.txt';
        const STORAGE_KEY_BOARD = 'crossplay_board_v3'; // Bumped version for new format
        const STORAGE_KEY_RACK = 'crossplay_rack_v3';
        const STORAGE_KEY_DICT = 'crossplay_dict_v1';

        // Standard Tile Values
        // NOTE: Lowercase keys are implicit 0 if not found here, but logic handles it manually.
        const LETTER_VALUES = {
            'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8, 'K': 5, 'L': 1, 'M': 3,
            'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1, 'S': 1, 'T': 1, 'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10,
            '?': 0
        };

        // Multiplier Types
        const M_NONE = 0;
        const M_2L = 1;
        const M_3L = 2;
        const M_2W = 3;
        const M_3W = 4;
        
        const MULT_CLASSES = {
            [M_2L]: 'mult-2l',
            [M_3L]: 'mult-3l',
            [M_2W]: 'mult-2w',
            [M_3W]: 'mult-3w'
        };

        const MULT_LABELS = {
            [M_2L]: '2L',
            [M_3L]: '3L',
            [M_2W]: '2W',
            [M_3W]: '3W'
        };

        // --- STATE ---
        let boardState = []; // Will be init in initializeBoard
        let dictionaryTrie = null;
        let isDictionaryLoaded = false;
        
        // Input Direction State
        let inputDirection = 'horizontal'; 
        let lastFocusedPos = { r: 7, c: 7 };
        
        // Blank tile entry mode
        let pendingBlankCoords = null; // {r, c} if waiting for letter after '?'

        // Results State
        let currentMoves = [];
        let sortMode = 'score'; // 'score' | 'tiles'
        let stickyMove = null; // Track clicked move for sticky preview

        // --- DATA STRUCTURES ---

        class TrieNode {
            constructor() {
                this.children = {};
                this.isWord = false;
            }
        }

        class Trie {
            constructor() {
                this.root = new TrieNode();
            }

            insert(word) {
                let node = this.root;
                for (let char of word) {
                    if (!node.children[char]) {
                        node.children[char] = new TrieNode();
                    }
                    node = node.children[char];
                }
                node.isWord = true;
            }

            // Check if prefix exists
            search(word) {
                let node = this.root;
                for (let char of word) {
                    if (!node.children[char]) return false;
                    node = node.children[char];
                }
                return node.isWord;
            }
        }

        // --- INITIALIZATION ---

        async function init() {
            renderBoard(); // Initial render (empty/default)
            setupEventListeners();
            loadState(); 
            await loadDictionary();
        }

        async function loadDictionary() {
            try {
                let text = localStorage.getItem(STORAGE_KEY_DICT);
                let fromCache = true;

                // If not in storage, fetch it
                if (!text) {
                    fromCache = false;
                    document.getElementById('loading-status').textContent = "Downloading dictionary...";
                    const response = await fetch(DICT_URL);
                    if (!response.ok) throw new Error("Network response was not ok");
                    text = await response.text();
                    
                    // Try to save to local storage (might fail if quota exceeded)
                    try {
                        localStorage.setItem(STORAGE_KEY_DICT, text);
                    } catch (e) {
                        console.warn("Could not save dictionary to local storage (quota exceeded likely).", e);
                    }
                } else {
                    document.getElementById('loading-status').textContent = "Loading from cache...";
                }

                const words = text.split(/\r?\n/);
                
                dictionaryTrie = new Trie();
                let count = 0;
                
                document.getElementById('loading-status').textContent = "Processing dictionary...";
                await new Promise(r => setTimeout(r, 50));

                for (let word of words) {
                    const cleanWord = word.trim().toUpperCase();
                    if (cleanWord.length > 1 && cleanWord.length <= 15) {
                        dictionaryTrie.insert(cleanWord);
                        count++;
                    }
                }
                
                console.log(`Dictionary loaded: ${count} words. Source: ${fromCache ? 'Cache' : 'Network'}`);
                document.getElementById('loading-overlay').style.display = 'none';
                isDictionaryLoaded = true;
            } catch (error) {
                console.error("Dictionary Load Error:", error);
                document.getElementById('loading-status').textContent = "Error loading dictionary. Please refresh.";
                document.getElementById('loading-status').classList.add('text-red-500');
                
                // If it failed and we had something in storage, maybe it was corrupt. Clear it.
                localStorage.removeItem(STORAGE_KEY_DICT);
            }
        }

        // --- LOCAL STORAGE ---

        function saveState() {
            try {
                localStorage.setItem(STORAGE_KEY_BOARD, JSON.stringify(boardState));
                localStorage.setItem(STORAGE_KEY_RACK, document.getElementById('rack-input').value);
            } catch (e) {
                console.error("Failed to save state", e);
            }
        }

        function loadState() {
            // Always start with fresh default multipliers
            initializeBoard();

            try {
                const savedBoard = localStorage.getItem(STORAGE_KEY_BOARD);
                const savedRack = localStorage.getItem(STORAGE_KEY_RACK);

                if (savedBoard) {
                    const parsed = JSON.parse(savedBoard);
                    // Overlay characters ONLY. Do not trust multipliers from save.
                    for(let r = 0; r < BOARD_SIZE; r++) {
                        for(let c = 0; c < BOARD_SIZE; c++) {
                            if (parsed[r] && parsed[r][c] && parsed[r][c].char) {
                                boardState[r][c].char = parsed[r][c].char;
                            }
                        }
                    }
                }

                if (savedRack) {
                    document.getElementById('rack-input').value = savedRack;
                }
            } catch (e) {
                console.error("Failed to load state", e);
            }
            // Render with the loaded chars + default multipliers
            renderBoard();
        }

        function initializeBoard() {
            boardState = Array(BOARD_SIZE).fill(null).map(() => 
                Array(BOARD_SIZE).fill(null).map(() => ({ char: '', mult: M_NONE }))
            );
            
            const T = M_3W; // Triple Word
            const D = M_2W; // Double Word
            const t = M_3L; // Triple Letter
            const d = M_2L; // Double Letter
            
            const setSym = (r, c, m) => {
                boardState[r][c].mult = m;
                boardState[r][14-c].mult = m;
                boardState[14-r][c].mult = m;
                boardState[14-r][14-c].mult = m;
            };

            setSym(0, 0, t); setSym(0, 7, d); setSym(7, 0, d); 
            setSym(1, 1, D); setSym(3, 3, d); 
            setSym(3, 7, D); setSym(7, 3, D);           
            setSym(1, 6, t); setSym(6, 1, t); setSym(4, 5, t);setSym(5, 4, t); 
            setSym(0, 3, T); setSym(4, 2, d); setSym(3, 0, T); setSym(5, 7, d); setSym(2, 4, d); setSym(7, 5, d); 
        }

        // --- DOM MANIPULATION ---

        function renderBoard() {
            // Ensure boardState exists (safe guard)
            if (!boardState || boardState.length === 0) initializeBoard();

            const gridEl = document.getElementById('game-board');
            gridEl.innerHTML = '';

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cellData = boardState[r][c];
                    const hasChar = cellData.char !== '';
                    const isCenter = (r === 7 && c === 7);
                    
                    const cellDiv = document.createElement('div');
                    
                    // Determine Class
                    let classes = ['cell'];
                    if (hasChar) {
                        classes.push('occupied');
                    } else {
                        // Only add multiplier class if NOT occupied
                        if (MULT_CLASSES[cellData.mult]) classes.push(MULT_CLASSES[cellData.mult]);
                    }
                    
                    // Pending blank check
                    if (pendingBlankCoords && pendingBlankCoords.r === r && pendingBlankCoords.c === c) {
                        classes.push('blank-pending');
                    }
                    
                    cellDiv.className = classes.join(' ');
                    cellDiv.dataset.r = r;
                    cellDiv.dataset.c = c;
                    
                    // 1. Center Star (Only if empty)
                    if (isCenter && !hasChar) {
                         const starSpan = document.createElement('span');
                         starSpan.className = 'absolute pointer-events-none text-yellow-400 text-2xl';
                         starSpan.innerHTML = '★'; // Unicode Star
                         // Add text shadow for visibility on white
                         starSpan.style.textShadow = '0 1px 2px rgba(0,0,0,0.2)';
                         cellDiv.appendChild(starSpan);
                    }

                    // 2. Multiplier Label (Only if empty and not center - center has star)
                    if (!hasChar && !isCenter && cellData.mult !== M_NONE) {
                        const span = document.createElement('span');
                        span.className = 'absolute text-[10px] opacity-50 pointer-events-none select-none';
                        span.innerText = MULT_LABELS[cellData.mult];
                        cellDiv.appendChild(span);
                    }

                    // 3. Input
                    const input = document.createElement('input');
                    input.value = cellData.char;
                    input.maxLength = 1;
                    
                    if (/[a-z]/.test(cellData.char)) {
                        input.classList.add('is-blank');
                    }
                    
                    // Event Listeners
                    input.addEventListener('input', (e) => handleCellInput(e, r, c));
                    input.addEventListener('keydown', (e) => handleCellKeydown(e, r, c));
                    input.addEventListener('focus', (e) => handleCellFocus(e, r, c));
                    input.addEventListener('click', (e) => e.target.select()); // Also select on click
                    
                    cellDiv.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        toggleDirection(r, c);
                    });

                    cellDiv.appendChild(input);
                    gridEl.appendChild(cellDiv);
                }
            }
        }

        function setupEventListeners() {
            document.getElementById('solve-btn').addEventListener('click', solve);
            document.getElementById('reset-board-btn').addEventListener('click', clearWordsOnly);
            document.getElementById('clear-rack-btn').addEventListener('click', () => {
                const rack = document.getElementById('rack-input');
                rack.value = '';
                rack.focus();
                saveState();
            });
            
            const rackInput = document.getElementById('rack-input');
            rackInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase().replace(/[^A-Z?*]/g, '');
                saveState();
            });

            // Sort Toggle Listeners
            document.getElementById('sort-score-btn').addEventListener('click', () => setSortMode('score'));
            document.getElementById('sort-tiles-btn').addEventListener('click', () => setSortMode('tiles'));

            // Global click to clear sticky preview
            document.addEventListener('click', (e) => {
                // If stickyMove exists and we didn't click inside a result item (handled by stopPropagation), clear it
                if (stickyMove) {
                    stickyMove = null;
                    clearPreview();
                    // Clear UI highlights
                    const list = document.getElementById('results-list');
                    if (list) {
                        Array.from(list.children).forEach(child => {
                            child.classList.remove('bg-indigo-100', 'border-indigo-200');
                        });
                    }
                }
            });
        }

        function setSortMode(mode) {
            sortMode = mode;
            
            // Update Buttons UI
            const scoreBtn = document.getElementById('sort-score-btn');
            const tilesBtn = document.getElementById('sort-tiles-btn');
            
            const activeClass = "bg-white text-slate-700 shadow-sm";
            const inactiveClass = "text-slate-500 hover:text-slate-700";
            
            if (mode === 'score') {
                scoreBtn.className = `px-3 py-1 text-xs font-bold rounded-md transition ${activeClass}`;
                tilesBtn.className = `px-3 py-1 text-xs font-bold rounded-md transition ${inactiveClass}`;
            } else {
                scoreBtn.className = `px-3 py-1 text-xs font-bold rounded-md transition ${inactiveClass}`;
                tilesBtn.className = `px-3 py-1 text-xs font-bold rounded-md transition ${activeClass}`;
            }

            if (currentMoves.length > 0) {
                displayResults(currentMoves);
            }
        }

        function handleCellFocus(e, r, c) {
            lastFocusedPos = { r, c };
            e.target.select(); // Select all text to allow overwrite
            updateDirectionIndicator();
        }

        function toggleDirection(r, c) {
            inputDirection = inputDirection === 'horizontal' ? 'vertical' : 'horizontal';
            const input = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"] input`);
            if (input) input.focus();
            updateDirectionIndicator();
        }

        function updateDirectionIndicator() {
            document.querySelectorAll('.next-target').forEach(el => el.classList.remove('next-target'));

            const { r, c } = lastFocusedPos;
            let targetR = r;
            let targetC = c;

            if (inputDirection === 'horizontal') targetC = c + 1;
            else targetR = r + 1;

            if (targetR < BOARD_SIZE && targetC < BOARD_SIZE) {
                const targetCell = document.querySelector(`.cell[data-r="${targetR}"][data-c="${targetC}"]`);
                if (targetCell) targetCell.classList.add('next-target');
            }
        }

        function handleCellInput(e, r, c) {
            let val = e.target.value;

            // 1. Check for Blank Tile Trigger
            if (val === '?') {
                e.target.value = ''; // Clear input
                pendingBlankCoords = { r, c };
                renderBoard(); // Re-render to show yellow indicator
                
                // RESTORE FOCUS
                const input = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"] input`);
                if(input) input.focus();
                
                return;
            }

            // 2. Handle Blank Entry (if pending)
            if (pendingBlankCoords && pendingBlankCoords.r === r && pendingBlankCoords.c === c) {
                if (/^[a-zA-Z]$/.test(val)) {
                    val = val.toLowerCase(); // Force lowercase for blank
                    pendingBlankCoords = null; // Reset pending state
                } else {
                    e.target.value = '';
                    return; // Invalid char for blank
                }
            } else {
                // 3. Normal Entry
                val = val.toUpperCase();
                // If user typed valid char
                if (!/^[A-Z]$/.test(val) && val !== '') {
                    // Try to recover if it was an overwrite scenario where value became 2 chars
                    // e.g. "A" -> user types "B" -> value is "AB" or "BA"
                    // Since we select() on focus, usually it replaces. 
                    // But if not selected, take the last char typed.
                    let lastChar = val.slice(-1).toUpperCase();
                    if (/^[A-Z]$/.test(lastChar)) {
                        val = lastChar;
                    } else {
                        e.target.value = boardState[r][c].char; // Revert
                        return;
                    }
                }
            }
            
            // Update State
            boardState[r][c].char = val;
            saveState();
            
            // Re-render specifically to update Styles (hide multiplier)
            // But we want to maintain focus and flow. 
            // RenderBoard destroys DOM. Let's do a soft DOM update or full render then refocus.
            renderBoard(); 
            
            // Restore Focus and Move
            if (val) {
                if (inputDirection === 'horizontal') moveFocus(r, c, 0, 1);
                else moveFocus(r, c, 1, 0);
            } else {
                // If cleared, stay put
                const input = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"] input`);
                if (input) input.focus();
            }
        }

        function handleCellKeydown(e, r, c) {
            // If we are in blank pending mode, Escape cancels it
            if (e.key === 'Escape' && pendingBlankCoords) {
                pendingBlankCoords = null;
                renderBoard();
                const input = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"] input`);
                if(input) input.focus();
                return;
            }

            if (e.key === 'Backspace' && e.target.value === '') {
                // Backspace moves back
                if (inputDirection === 'horizontal') moveFocus(r, c, 0, -1);
                else moveFocus(r, c, -1, 0);
            } else if (e.key === 'ArrowRight') {
                moveFocus(r, c, 0, 1);
            } else if (e.key === 'ArrowLeft') {
                moveFocus(r, c, 0, -1);
            } else if (e.key === 'ArrowDown') {
                moveFocus(r, c, 1, 0);
            } else if (e.key === 'ArrowUp') {
                moveFocus(r, c, -1, 0);
            }
        }

        function moveFocus(r, c, dr, dc) {
            let nr = r + dr;
            let nc = c + dc;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                const target = document.querySelector(`.cell[data-r="${nr}"][data-c="${nc}"] input`);
                if (target) {
                    target.focus();
                    target.select(); // Ensure select on move
                }
            }
        }

        function clearWordsOnly() {
            boardState.forEach(row => row.forEach(cell => { cell.char = ''; }));
            stickyMove = null; // Clear sticky state
            renderBoard();
            saveState();
            document.getElementById('results-list').innerHTML = '<div class="p-8 text-center text-slate-400">Words cleared.</div>';
            document.getElementById('results-count').innerText = '0 found';
        }

        // --- SOLVER LOGIC ---

        function solve() {
            if (!isDictionaryLoaded) {
                alert("Dictionary not loaded yet.");
                return;
            }

            const rackStr = document.getElementById('rack-input').value.toUpperCase();
            if (rackStr.length === 0) {
                alert("Please enter letters in your rack.");
                return;
            }

            const solveBtn = document.getElementById('solve-btn');
            const spinner = document.getElementById('solve-spinner');
            solveBtn.disabled = true;
            spinner.classList.remove('hidden');

            setTimeout(() => {
                const results = runSolver(rackStr);
                currentMoves = results; // Store for sorting
                displayResults(results);
                solveBtn.disabled = false;
                spinner.classList.add('hidden');
            }, 100);
        }

        function runSolver(rackStr) {
            let moves = [];
            let isFirstTurn = !boardState.some(row => row.some(cell => cell.char));
            
            const findMovesForOrientation = (grid, isTransposed) => {
                const anchors = findAnchors(grid);
                const crossChecks = computeCrossChecks(grid, dictionaryTrie);

                for (let r = 0; r < BOARD_SIZE; r++) {
                    const rowAnchors = anchors[r];
                    if (rowAnchors.length === 0) continue;

                    for (let c of rowAnchors) {
                        let limit = 0;
                        let node = dictionaryTrie.root;
                        let prefix = '';

                        // Case 1: Connect to existing word on left
                        if (c > 0 && grid[r][c-1].char) {
                            let k = c - 1;
                            while (k >= 0 && grid[r][k].char) k--;
                            k++; 
                            
                            let validPrefix = true;
                            for (let i = k; i < c; i++) {
                                let char = grid[r][i].char.toUpperCase(); // Ensure Trie match is Upper
                                prefix += char;
                                if (node.children[char]) {
                                    node = node.children[char];
                                } else {
                                    validPrefix = false;
                                    break;
                                }
                            }
                            if (!validPrefix) continue;
                        } 
                        // Case 2: Empty space on left
                        else {
                            if (c > 0) {
                                let k = c - 1;
                                while (k >= 0 && !grid[r][k].isAnchor && !grid[r][k].char) k--;
                                let dist = 0;
                                let p = c - 1;
                                while(p >= 0 && !grid[r][p].char && !grid[r][p].isAnchor) {
                                    dist++;
                                    p--;
                                }
                                limit = dist;
                            }
                        }

                        leftPart(grid, r, c, prefix, node, limit, rackStr, moves, isTransposed, crossChecks, isFirstTurn, []);
                    }
                }
            };

            identifyAnchors(boardState);
            findMovesForOrientation(boardState, false);

            const transposedBoard = transpose(boardState);
            identifyAnchors(transposedBoard);
            findMovesForOrientation(transposedBoard, true);

            identifyAnchors(boardState); 

            return moves;
        }

        // --- ALGORITHM HELPERS ---

        function transpose(grid) {
            return grid[0].map((_, colIndex) => grid.map(row => row[colIndex]));
        }

        function identifyAnchors(grid) {
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    grid[r][c].isAnchor = false;
                }
            }

            let hasTiles = false;
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if (grid[r][c].char) {
                        hasTiles = true;
                        if (r>0 && !grid[r-1][c].char) grid[r-1][c].isAnchor = true;
                        if (r<14 && !grid[r+1][c].char) grid[r+1][c].isAnchor = true;
                        if (c>0 && !grid[r][c-1].char) grid[r][c-1].isAnchor = true;
                        if (c<14 && !grid[r][c+1].char) grid[r][c+1].isAnchor = true;
                    }
                }
            }
            if (!hasTiles) grid[7][7].isAnchor = true;
        }

        function findAnchors(grid) {
            let anchors = [];
            for (let r=0; r<BOARD_SIZE; r++) {
                let rowAnchors = [];
                for(let c=0; c<BOARD_SIZE; c++) {
                    if (grid[r][c].isAnchor) rowAnchors.push(c);
                }
                anchors.push(rowAnchors);
            }
            return anchors;
        }

        function computeCrossChecks(grid, trie) {
            let checks = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));

            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if (grid[r][c].char) continue;

                    let up = r - 1;
                    while(up >= 0 && grid[up][c].char) up--;
                    let down = r + 1;
                    while(down < BOARD_SIZE && grid[down][c].char) down++;
                    
                    if (up === r-1 && down === r+1) {
                        checks[r][c] = null; 
                        continue;
                    }

                    let validChars = [];
                    let prefix = '';
                    for(let k=up+1; k<r; k++) prefix += grid[k][c].char.toUpperCase();
                    
                    let suffix = '';
                    for(let k=r+1; k<down; k++) suffix += grid[k][c].char.toUpperCase();

                    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                    for(let char of alphabet) {
                        const word = prefix + char + suffix;
                        if (trie.search(word)) {
                            validChars.push(char);
                        }
                    }
                    checks[r][c] = validChars;
                }
            }
            return checks;
        }

        function leftPart(grid, r, c, partialWord, node, limit, rack, moves, isVert, crossChecks, isFirstTurn, blanks) {
            extendRight(grid, r, c, partialWord, node, rack, moves, isVert, crossChecks, isFirstTurn, blanks);

            if (limit > 0) {
                for (let edge in node.children) {
                    let rackIdx = rack.indexOf(edge);
                    let isBlank = false;
                    if (rackIdx === -1) {
                        rackIdx = rack.indexOf('?');
                        isBlank = true;
                    }
                    if (rackIdx === -1) {
                         rackIdx = rack.indexOf('*'); 
                         isBlank = true;
                    }

                    if (rackIdx !== -1) {
                        let newRack = rack.slice(0, rackIdx) + rack.slice(rackIdx + 1);
                        let newBlanks = isBlank ? [...blanks, partialWord.length] : blanks;
                        leftPart(grid, r, c, partialWord + edge, node.children[edge], limit - 1, newRack, moves, isVert, crossChecks, isFirstTurn, newBlanks);
                    }
                }
            }
        }

        function extendRight(grid, r, c, partialWord, node, rack, moves, isVert, crossChecks, isFirstTurn, blanks) {
            for (let i = 0; i < partialWord.length; i++) {
                const checkCol = c - partialWord.length + i;
                const char = partialWord[i];
                if (!grid[r][checkCol].char) {
                    if (crossChecks[r][checkCol] && !crossChecks[r][checkCol].includes(char)) return; 
                }
            }
            
            if (c >= BOARD_SIZE) {
                if (node.isWord) evaluateMove(grid, r, c, partialWord, moves, isVert, isFirstTurn, blanks);
                return;
            }

            if (!grid[r][c].char) {
                if (node.isWord && isValidMoveEnd(grid, r, c)) {
                    evaluateMove(grid, r, c, partialWord, moves, isVert, isFirstTurn, blanks);
                }

                for (let edge in node.children) {
                    if (crossChecks[r][c] && !crossChecks[r][c].includes(edge)) continue;

                    let rackIdx = rack.indexOf(edge);
                    let isBlank = false;
                    if (rackIdx === -1) {
                        rackIdx = rack.indexOf('?');
                        isBlank = true;
                    }
                    if (rackIdx === -1) {
                         rackIdx = rack.indexOf('*');
                         isBlank = true;
                    }

                    if (rackIdx !== -1) {
                        let newRack = rack.slice(0, rackIdx) + rack.slice(rackIdx + 1);
                        let newBlanks = isBlank ? [...blanks, partialWord.length] : blanks;
                        extendRight(grid, r, c + 1, partialWord + edge, node.children[edge], newRack, moves, isVert, crossChecks, isFirstTurn, newBlanks);
                    }
                }
            } else {
                let existingChar = grid[r][c].char.toUpperCase();
                if (node.children[existingChar]) {
                    extendRight(grid, r, c + 1, partialWord + existingChar, node.children[existingChar], rack, moves, isVert, crossChecks, isFirstTurn, blanks);
                }
            }
        }

        function isValidMoveEnd(grid, r, c) {
            if (c >= BOARD_SIZE) return true;
            return !grid[r][c].char;
        }

        function evaluateMove(grid, r, endC, word, moves, isVert, isFirstTurn, blanks) {
            let startC = endC - word.length;
            let placedTile = false;
            let coveredTiles = 0;
            
            let score = 0;
            let wordMult = 1;
            let mainWordScore = 0;
            let crossWordsScore = 0;
            
            let displayWord = '';

            for (let i = 0; i < word.length; i++) {
                let currentC = startC + i;
                let char = word[i];
                let isBlank = blanks.includes(i);
                
                displayWord += isBlank ? char.toLowerCase() : char;
                
                if (grid[r][currentC].char) {
                    // Check if EXISTING tile is a blank (lowercase)
                    let existingVal = grid[r][currentC].char;
                    let existingIsBlank = (existingVal === existingVal.toLowerCase() && existingVal !== existingVal.toUpperCase());
                    
                    mainWordScore += existingIsBlank ? 0 : (LETTER_VALUES[char] || 0);
                    coveredTiles++;
                } else {
                    placedTile = true;
                    let charScore = isBlank ? 0 : (LETTER_VALUES[char] || 0);
                    let m = grid[r][currentC].mult;
                    
                    let letterMult = 1;
                    if (m === M_2L) letterMult = 2;
                    if (m === M_3L) letterMult = 3;
                    
                    if (m === M_2W) wordMult *= 2;
                    if (m === M_3W) wordMult *= 3;
                    
                    mainWordScore += (charScore * letterMult);

                    let crossScore = getCrossWordScore(grid, r, currentC, char, isBlank);
                    crossWordsScore += crossScore;
                }
            }

            if (!placedTile) return; 
            
            if (isFirstTurn) {
                let spansCenter = false;
                if (isVert) {
                    if (r === 7 && startC <= 7 && (startC + word.length - 1) >= 7) spansCenter = true;
                } else {
                    if (r === 7 && startC <= 7 && (startC + word.length - 1) >= 7) spansCenter = true;
                }
                if (!spansCenter) return;
            } else {
                if (coveredTiles === 0 && crossWordsScore === 0) return;
            }

            let totalScore = (mainWordScore * wordMult) + crossWordsScore;
            
            let tilesUsed = word.length - coveredTiles;
            if (tilesUsed === 7) totalScore += 50;

            let realR = isVert ? startC : r;
            let realC = isVert ? r : startC;
            let coord = String.fromCharCode(65 + realC) + (realR + 1); 
            
            moves.push({
                word: displayWord,
                score: totalScore,
                tilesUsed: tilesUsed,
                r: realR,
                c: realC,
                isVert: isVert,
                coord: coord
            });
        }

        function getCrossWordScore(grid, r, c, char, isBlank) {
            let up = r - 1;
            while(up >= 0 && grid[up][c].char) up--;
            let down = r + 1;
            while(down < BOARD_SIZE && grid[down][c].char) down++;
            
            if (up === r-1 && down === r+1) return 0; 

            let wordScore = 0;
            let wordMult = 1; 
            
            let m = grid[r][c].mult;
            if (m === M_2W) wordMult = 2;
            if (m === M_3W) wordMult = 3;

            let charVal = isBlank ? 0 : LETTER_VALUES[char];
            
            if (m === M_2L) charVal *= 2;
            if (m === M_3L) charVal *= 3;
            
            wordScore += charVal;

            for(let k=up+1; k<r; k++) {
                let v = grid[k][c].char;
                let isB = (v === v.toLowerCase() && v !== v.toUpperCase());
                wordScore += isB ? 0 : LETTER_VALUES[v.toUpperCase()];
            }
            for(let k=r+1; k<down; k++) {
                let v = grid[k][c].char;
                let isB = (v === v.toLowerCase() && v !== v.toUpperCase());
                wordScore += isB ? 0 : LETTER_VALUES[v.toUpperCase()];
            }

            return wordScore * wordMult;
        }

        // --- UI RESULTS ---

        function displayResults(moves) {
            const listEl = document.getElementById('results-list');
            const countEl = document.getElementById('results-count');
            
            listEl.innerHTML = '';
            countEl.innerText = `${moves.length} found`;

            // Reset sticky state on new results
            stickyMove = null;
            clearPreview();

            if (moves.length === 0) {
                listEl.innerHTML = '<div class="p-4 text-center text-slate-500">No valid moves found.</div>';
                return;
            }

            // Remove duplicates (same word, same position, same score)
            const uniqueMoves = [];
            const seen = new Set();
            moves.forEach(m => {
                const key = `${m.word}-${m.r}-${m.c}-${m.isVert}`;
                if(!seen.has(key)) {
                    seen.add(key);
                    uniqueMoves.push(m);
                }
            });

            // Sorting Logic
            uniqueMoves.sort((a, b) => {
                if (sortMode === 'score') return b.score - a.score;
                if (sortMode === 'tiles') return b.tilesUsed - a.tilesUsed;
                return 0;
            });

            // Limit display to top 50
            const displayMoves = uniqueMoves.slice(0, 50);

            displayMoves.forEach((move, index) => {
                const item = document.createElement('div');
                item.className = 'flex justify-between items-center p-3 border-b border-slate-100 hover:bg-indigo-50 cursor-pointer transition group';
                item.innerHTML = `
                    <div class="flex items-center gap-3">
                        <span class="text-slate-400 font-mono text-sm w-6">${index + 1}.</span>
                        <div>
                            <div class="font-bold text-slate-800 text-lg tracking-wide">${move.word}</div>
                            <div class="text-xs text-slate-500 font-mono flex gap-2">
                                <span>${move.coord} ${move.isVert ? '↓' : '→'}</span>
                                <span class="text-indigo-500">${move.tilesUsed} tiles</span>
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center gap-3">
                        <div class="font-bold text-indigo-600 text-xl">${move.score}</div>
                        <button class="play-btn bg-green-500 hover:bg-green-600 text-white text-xs font-bold px-2 py-1 rounded shadow-sm opacity-0 group-hover:opacity-100 transition">PLAY</button>
                    </div>
                `;
                
                // Interaction Listeners
                item.addEventListener('mouseenter', () => {
                    if (!stickyMove) previewMove(move);
                });
                item.addEventListener('mouseleave', () => {
                    if (!stickyMove) clearPreview();
                });
                
                // Sticky Click Logic
                item.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent global click from clearing
                    
                    if (stickyMove === move) {
                        // Deselect if clicking same one
                        stickyMove = null;
                        clearPreview();
                        item.classList.remove('bg-indigo-100', 'border-indigo-200');
                    } else {
                        // Select new one
                        stickyMove = move;
                        previewMove(move);
                        
                        // Clear other highlights
                        Array.from(listEl.children).forEach(child => {
                            child.classList.remove('bg-indigo-100', 'border-indigo-200');
                        });
                        
                        // Add highlight
                        item.classList.add('bg-indigo-100', 'border-indigo-200');
                    }
                });
                
                // Play Button Click
                const playBtn = item.querySelector('.play-btn');
                playBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent item click logic if any
                    playMove(move);
                });

                listEl.appendChild(item);
            });
        }
        
        function playMove(move) {
            const rackInput = document.getElementById('rack-input');
            let rack = rackInput.value.split('');
            const { r, c, word, isVert } = move;

            for (let i = 0; i < word.length; i++) {
                let cr = isVert ? r + i : r;
                let cc = isVert ? c : c + i;
                let char = word[i]; // 'a' or 'A'

                // Only process if board was empty (meaning we used a tile from rack)
                if (boardState[cr][cc].char === '') {
                     // Update Board
                     boardState[cr][cc].char = char; // Stores 'a' for blank, 'A' for normal

                     // Update Rack
                     if (char === char.toLowerCase() && char !== char.toUpperCase()) {
                         // It's a blank
                         let idx = rack.indexOf('?');
                         if (idx === -1) idx = rack.indexOf('*');
                         if (idx !== -1) rack.splice(idx, 1);
                     } else {
                         // Normal letter
                         let idx = rack.indexOf(char);
                         if (idx !== -1) rack.splice(idx, 1);
                     }
                }
            }

            // Update UI
            rackInput.value = rack.join('');
            
            // Clear sticky state since move is played
            stickyMove = null;
            
            renderBoard();
            saveState();
            
            // Feedback
            document.getElementById('results-list').innerHTML = '<div class="p-8 text-center text-green-600 font-bold">Move played!</div>';
            document.getElementById('results-count').innerText = '0 found';
            currentMoves = [];
        }

        function previewMove(move) {
            clearPreview();
            
            const r = move.r;
            const c = move.c;
            const displayWord = move.word;
            const isVert = move.isVert;

            for (let i = 0; i < displayWord.length; i++) {
                let cr = isVert ? r + i : r;
                let cc = isVert ? c : c + i;
                
                if (!boardState[cr][cc].char) {
                    const cell = document.querySelector(`.cell[data-r="${cr}"][data-c="${cc}"]`);
                    if (cell) {
                        cell.classList.add('phantom');
                        const input = cell.querySelector('input');
                        input.dataset.original = input.value;
                        input.value = displayWord[i]; // Show upper or lower
                    }
                }
            }
        }

        function clearPreview() {
            document.querySelectorAll('.cell.phantom').forEach(cell => {
                cell.classList.remove('phantom');
                const input = cell.querySelector('input');
                input.value = ''; 
            });
        }

        init();
    </script>
</body>
</html>
